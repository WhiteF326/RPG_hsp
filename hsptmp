;#const giX 10
;#const giY 11
randomize
#const windowMulti 125
#const windowSize 480 * windowMulti / 100
#module
#defcfunc pow int x, int y
	dim ans : ans = 1
	repeat y : ans = ans * x : loop
	return ans
#global

*init
	;マップチップ読み込み
	buffer 32
	picload "Chips/MapChip.png", 32

	;メインウィンドウ読み込み
	screen 0, windowSize, windowSize, 0

	;マップ変数用意
	dim mSize : mSize = 24
	dim frq : frq = 8
	dim chipSize : chipSize = windowSize / mSize
	dim map, mSize, mSize
	sdim buf, 32000
	notesel buf : noteload "Elements/ChipPoint.txt"
	dim mapPoints, 2, notemax / 2			;todo 2で割り切れない時の対策
	repeat notemax
		sdim t, 16 : noteget t, cnt
		mapPoints(cnt \ 2, cnt / 2) = int(t)
	loop
	
*main
	gosub *mapGenerate
	gosub *mapPaint
	stop

*mapGenerate
	dim XM : XM = mSize / frq
	dim YM : YM = mSize / frq
	dim rooms, pow((mSize / frq), 2), 4
	dim floorCount : dim floors, pow(24, 2), 2
	dim adj, 9, 2
	repeat XM
		x = cnt
		repeat YM
			rNum = x * XM + cnt
			if y + 1 ! YM : adj(rNum, 0) = rNum + 1 : else : adj(rNum, 0) = -1
			if x + 1 ! XM : adj(rNum, 1) = rNum + XM : else : adj(rNum, 1) = -1
		loop
	loop
	repeat XM
		xr = cnt
		repeat YM
			yr = cnt
			dim xrm : dim yrm
			if xr + 1 = XM{
				xrm = mSize - ((XM - 1) * frq)
			}else{
				xrm = frq
			}
			if yr + 1 = YM{
				yrm = mSize - ((YM - 1) * frq)
			}else{
				yrm = frq
			}
			dim xs : xs = rnd(xrm) + 1
			dim ys : ys = rnd(yrm) + 1
			if(xs == xrm) : xp = 0 : else : xp = rnd(xrm - xs)
			if(ys == yrm) : yp = 0 : else : yp = rnd(yrm - ys)
			repeat xs
				x = cnt
				repeat ys
					y = cnt
					map(x + xp + xr * frq, y + yp + yr * frq) = 1
					if (xs > 1) && (ys > 1){
						floors(floorCount, 0) = x + xp + xr * frq
						floors(floorCount, 1) = y + yp + yr * frq
						floorCount++
					}
				loop
			loop
			rooms(xr * XM + yr, 0) = xr * frq + xp
			rooms(xr * XM + yr, 1) = yr * frq + yp
			rooms(xr * XM + yr, 2) = xr * frq + xp + xs
			rooms(xr * XM + yr, 3) = yr * frq + yp + ys
		loop
	loop
	//階段を配置
	//通路生成
	dim notAdjArr, XM * YM * 2, 3 : dim nAAcnt
	repeat XM * YM
		i = cnt
		repeat 2
			dim retEx : dim locked_x : dim locked_y
			if adj(i, cnt) ! -1{
				if cnt = 0 {
					locked_y = rooms(i, 3)
					for x, rooms(i, 0), rooms(i, 2), 1
						retEx += map(x, locked_y)
					next
				}else{
					locked_x = rooms(i, 2)
					for y, rooms(i, 1), rooms(i, 3), 1
						retEx += map(locked_x, y)
					next
				}
				if retEx = 0{
					notAdjArr(nAAcnt, 0) = i
					notAdjArr(nAAcnt, 1) = adj(i, cnt)
					notAdjArr(nAAcnt, 2) = cnt
					nAAcnt++
				}
			}
		loop
	loop
	//c_Pos作成
	return

*mapPaint
	repeat mSize
		x = cnt
		repeat mSize
			pos x * chipSize, cnt * chipSize
			gzoom chipSize, chipSize, 32, mapPoints(0, map(x, cnt)) * 16, mapPoints(1, map(x, cnt)) * 16, 16, 16
		loop
	loop
	return
