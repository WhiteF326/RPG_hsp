;#const giX 10
;#const giY 11
randomize
#include "hspmath.as"
#const windowMulti 125
#const windowSize 480 * windowMulti / 100
#module
	; 結果が大きくなりやすいイカサマ乱数
	#defcfunc bigrnd int rndmax
		if(rndmax = 1) : return 1
		dim ans
		repeat rndmax - 1
			if rnd(100) > 1 : ans++
		loop
		return ans
#global

*init
	;マップチップ読み込み
	buffer 32
	picload "Chips/MapChip.png", 32

	;メインウィンドウ読み込み
	screen 0, windowSize, windowSize, 0

	;マップ変数用意
	dim mSize : mSize = 48
	dim frq : frq = 2
	dim chipSize : chipSize = windowSize / mSize
	dim map, mSize, mSize
	sdim buf, 32000
	notesel buf : noteload "Elements/ChipPoint.txt"
	dim mapPoints, 2, notemax / 2			;todo 2で割り切れない時の対策
	repeat notemax
		sdim t, 16 : noteget t, cnt
		mapPoints(cnt \ 2, cnt / 2) = int(t)
	loop

*main
	gosub *mapGenerate
	gosub *mapPaint
	stop

*mapGenerate
	//縦と横にfrq回数仕切りを作成する
	dim rTable, mSize - 2
	repeat mSize - 2 : rTable(cnt) = cnt + 1 : loop

	//ランダムソート
	repeat mSize - 2
		dim r : r = rnd(mSize - 2 - cnt)
		dim tmp : tmp = rTable(r)
		rTable(r) = rTable(mSize - cnt - 3)
		rTable(mSize - cnt - 3) = tmp
	loop

	//仕切りの選択
	dim xDivPoint, frq + 2 : dim yDivPoint, frq + 2
	repeat frq
		xDivPoint(cnt + 1) = rTable(cnt)
		yDivPoint(cnt + 1) = rTable(mSize - cnt - 3)
	loop
	xDivPoint(frq + 1) = mSize : yDivPoint(frq + 1) = mSize

	//仕切り位置のソート
	if frq > 1{
		//sorting xDivPoint
		repeat frq
			dim i : i = cnt
			repeat frq - i
				if xDivPoint(cnt) > xDivPoint(cnt + 1){
					dim tmp : tmp = xDivPoint(cnt)
					xDivPoint(cnt) = xDivPoint(cnt + 1)
					xDivPoint(cnt + 1) = tmp
				}
			loop
		loop
		//sorting yDivPoint
		repeat frq
			dim i : i = cnt
			repeat frq - i
				if yDivPoint(cnt) > yDivPoint(cnt + 1){
					dim tmp : tmp = yDivPoint(cnt)
					yDivPoint(cnt) = yDivPoint(cnt + 1)
					yDivPoint(cnt + 1) = tmp
				}
			loop
		loop
	}

	//小部屋の生成
	//直前の仕切りと比較して差が1の場合、自身は1つ正へ移動する
	dim roomsInfo, int(pow(frq + 1, 2)), 4
	repeat length(xDivPoint) - 1
		if xDivPoint(cnt + 1) - xDivPoint(cnt) = 1 : xDivPoint(cnt + 1)++
		dim xPtr : xPtr = cnt
		repeat length(yDivPoint) - 1
			if yDivPoint(cnt + 1) - yDivPoint(cnt) = 1 : yDivPoint(cnt + 1)++
			dim targetRoom : targetRoom = xPtr * (frq + 1) + cnt
			//左端と上端を決定する
			if xDivPoint(xPtr + 1) - xDivPoint(xPtr) = 2 : roomsInfo(targetRoom, 0) = xDivPoint(xPtr) + 1 : else{
				roomsInfo(targetRoom, 0) = rnd(xDivPoint(xPtr + 1) - xDivPoint(xPtr) - 2) + xDivPoint(xPtr) + 1
			}
			;roomsInfo(targetRoom, 0) = rnd(xDivPoint(xPtr + 1) - xDivPoint(xPtr) - 2) + xDivPoint(xPtr) + 1
			if yDivPoint(cnt + 1) - yDivPoint(cnt) = 2 : roomsInfo(targetRoom, 2) = yDivPoint(cnt) + 1 : else{
				roomsInfo(targetRoom, 1) = rnd(yDivPoint(cnt + 1) - yDivPoint(cnt) - 2) + yDivPoint(cnt) + 1
			}
			;roomsInfo(targetRoom, 1) = rnd(yDivPoint(cnt + 1) - yDivPoint(cnt) - 2) + yDivPoint(cnt) + 1
			//右端と下端を決定する
			if roomsInfo(targetRoom, 0) = xDivPoint(xPtr + 1) - 1 : roomsInfo(targetRoom, 2) = 1: else{
				roomsInfo(targetRoom, 2) = bigrnd(xDivPoint(xPtr + 1) - roomsInfo(targetRoom, 0)) + 1
			}
			if roomsInfo(targetRoom, 1) = yDivPoint(cnt + 1) - 1 : roomsInfo(targetRoom, 3) = 1: else{
				roomsInfo(targetRoom, 3) = bigrnd(yDivPoint(cnt + 1) - roomsInfo(targetRoom, 1)) + 1
			}

		loop
	loop
	//実際の埋め立て
	repeat length(roomsInfo)
		targetRoom = cnt
		repeat roomsInfo(targetRoom, 2)
			dim x : x = cnt
			repeat roomsInfo(targetRoom, 3)
				map(x + roomsInfo(targetRoom, 0), cnt + roomsInfo(targetRoom, 1)) = 1
			loop
		loop
	loop

	//通路の生成
	repeat frq
		dim xRoot : xRoot = cnt
		repeat frq
			//右へ通路を作る
		loop
	loop

	//仕切り部で通路を繋ぐ

	//完成
	return

*mapPaint
	gsel 0
	repeat mSize
		x = cnt
		repeat mSize
			pos x * chipSize, cnt * chipSize
			gzoom chipSize, chipSize, 32, mapPoints(0, map(x, cnt)) * 16, mapPoints(1, map(x, cnt)) * 16, 16, 16
		loop
	loop
	return
